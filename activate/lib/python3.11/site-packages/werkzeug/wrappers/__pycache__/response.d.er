##[pylyzer] failed /home/ether/Desktop/testingThings/realstate/activate/lib/python3.11/site-packages/werkzeug/wrappers/response.py 1753141474 32459
.___v_desugar_1: Never
.annotations: Never
.json: Never

.t: Never

.___v_desugar_2: Never
.HTTPStatus: Never
.___v_desugar_3: Never
.urljoin: Never
.___v_desugar_4: Never
._get_environ: Never
.___v_desugar_5: Never
.Headers: Never
.___v_desugar_6: Never
.generate_etag: Never
.___v_desugar_7: Never
.http_date: Never
.___v_desugar_8: Never
.is_resource_modified: Never
.___v_desugar_9: Never
.parse_etags: Never
.___v_desugar_10: Never
.parse_range_header: Never
.___v_desugar_11: Never
.remove_entity_headers: Never
.___v_desugar_12: Never
._SansIOResponse: Never
.___v_desugar_13: Never
.iri_to_uri: Never
.___v_desugar_14: Never
.cached_property: Never
.___v_desugar_15: Never
._RangeWrapper: Never
.___v_desugar_16: Never
.ClosingIterator: Never
.___v_desugar_17: Never
.get_current_url: Never

.___v_desugar_18: Never
.StartResponse: Never
.___v_desugar_19: Never
.WSGIApplication: Never
.___v_desugar_20: Never
.WSGIEnvironment: Never
.___v_desugar_21 = pyimport "request"
.request = pyimport "request"
.Request: {wrappers.request.Request}


._iter_encoded: (iterable: global::Iterable(Never)) -> NoneType
.Response: ClassType
.Response <: Never
.Response._on_close: global::List!(Never, _: Nat)
.Response.response: Never
.Response.direct_passthrough: Bool
.Response.__call__: (self: wrappers.response.Response, environ: Obj, start_response: Obj) -> Never
.Response.implicit_sequence_conversion: {True}
.Response.autocorrect_location_header: {False}
.Response.automatically_set_content_length: {True}
.Response.call_on_close: |T: Type|(self: wrappers.response.Response, func: T) -> T
.Response.__repr__: (self: wrappers.response.Response) -> Str
.Response.force_type: (cls: ClassType, response: wrappers.response.Response, environ: Obj := Obj) -> wrappers.response.Response
.Response.from_app: (cls: () -> wrappers.response.Response, app: Obj, environ: Obj, buffered: Bool := {False} and Bool) -> wrappers.response.Response
.Response.get_data: (self: wrappers.response.Response, as_text: Obj := Obj) -> global::Bytes
.Response.get_data: (self: wrappers.response.Response, as_text: Obj) -> Str
.Response.get_data: (self: wrappers.response.Response, as_text: Bool := Bool) -> global::Bytes or Str
.Response.set_data: (self: wrappers.response.Response, value: global::Bytes or Str) -> NoneType
.Response.data: Never
.Response.calculate_content_length: (self: wrappers.response.Response) -> NoneType or Int
.Response._ensure_sequence: (self: wrappers.response.Response, mutable: Bool := Bool and Bool) -> NoneType
.Response.make_sequence: (self: wrappers.response.Response) -> NoneType
.Response.iter_encoded: (self: wrappers.response.Response) -> global::Iterable(Never)
.Response.is_streamed : (self: wrappers.response.Response) -> Bool
.Response.is_streamed: Never
.Response.is_sequence : (self: wrappers.response.Response) -> Bool
.Response.is_sequence: Never
.Response.close: (self: wrappers.response.Response) -> NoneType
.Response.__enter__: (self: wrappers.response.Response) -> wrappers.response.Response
.Response.__exit__: (self: wrappers.response.Response, exc_type: Obj, exc_value: Obj, tb: Obj) -> NoneType
.Response.freeze: (self: wrappers.response.Response) -> NoneType
.Response.get_wsgi_headers: (self: wrappers.response.Response, environ: Obj) -> Never
.Response.get_app_iter: (self: wrappers.response.Response, environ: Obj) -> Never
.Response.get_wsgi_response: (self: wrappers.response.Response, environ: Obj) -> global::Tuple([Never, Str, global::List!(global::Tuple([Str, Str]), _: Nat)])
.Response.__call__: (self: wrappers.response.Response, environ: Obj, start_response: Obj) -> Never
.Response.json_module: Never
.Response.json : (self: wrappers.response.Response) -> Never
.Response.json: Never
.Response.get_json: |Type_13344 :> {Ellipsis}|(self: wrappers.response.Response, force: Bool := Bool and Bool, silent: Type_13344 := Type_13344 and Type_13344) -> Never
.Response.get_json: (self: wrappers.response.Response, force: Bool := Bool, silent: Bool := Bool) -> Never
.Response.get_json: (self: wrappers.response.Response, force: Bool := Bool, silent: Bool := Bool) -> Never
.Response.stream: (self: wrappers.response.Response) -> Never
.Response._wrap_range_response: (self: wrappers.response.Response, start: Int, length: Int) -> NoneType
.Response._is_range_request_processable: (self: wrappers.response.Response, environ: Obj) -> Bool
.Response._process_range_request: (self: wrappers.response.Response, environ: Obj, complete_length: NoneType or Int, accept_ranges: Bool or Str) -> Bool
.Response.make_conditional: (self: wrappers.response.Response, request_or_environ: Obj, accept_ranges: Bool or Str := Bool or Str, complete_length: NoneType or Int := NoneType or Int) -> wrappers.response.Response
.Response.add_etag: (self: wrappers.response.Response, overwrite: Bool := Bool and Bool, weak: Bool := Bool and Bool) -> NoneType

.ResponseStream: ClassType
wrappers = pyimport "wrappers"
.ResponseStream.response: wrappers.response.Response
.ResponseStream.closed: Never
.ResponseStream.__call__: (response: wrappers.response.Response) -> wrappers.response.ResponseStream
.ResponseStream.mode: {"wb+"}
.ResponseStream.write: (self: wrappers.response.ResponseStream, value: global::Bytes) -> Int
.ResponseStream.writelines: (self: wrappers.response.ResponseStream, seq: global::Iterable(global::Bytes)) -> NoneType
.ResponseStream.close: (self: wrappers.response.ResponseStream) -> NoneType
.ResponseStream.flush: (self: wrappers.response.ResponseStream) -> NoneType
.ResponseStream.isatty: (self: wrappers.response.ResponseStream) -> Bool
.ResponseStream.tell: (self: wrappers.response.ResponseStream) -> Int
.ResponseStream.encoding : (self: wrappers.response.ResponseStream) -> Str
.ResponseStream.encoding: Str

