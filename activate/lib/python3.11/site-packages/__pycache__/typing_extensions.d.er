##[pylyzer] failed /home/ether/Desktop/testingThings/realstate/activate/lib/python3.11/site-packages/typing_extensions.py 1753384551 157408
.abc: Never

.builtins: Never

.collections: Never

.collections: Never

.contextlib: Never

.enum: Never

.functools: Never

.inspect: Never

.io: Never

.keyword: Never

.operator: Never

.sys: Never

._types: Never

.typing: Never

.warnings: Never


.annotationlib: Never



.__all__: global::List!({"MutableMapping", "ItemsView", "Sequence", "TypeVar", "Format", "Self", "NewType", "Iterator", "Hashable", "assert_never", "is_protocol", "FrozenSet", "AsyncIterator", "KeysView", "ContextManager", "ForwardRef", "ValuesView", "get_origin", "Reader", "Text", "SupportsIndex", "get_args", "Final", "AnyStr", "Tuple", "ParamSpec", "ReadOnly", "Annotated", "Reversible", "Collection", "TypeAliasType", "ClassVar", "NotRequired", "NoDefault", "NoExtraItems", "BinaryIO", "Counter", "clear_overloads", "final", "get_original_bases", "IntVar", "Callable", "is_typeddict", "Generic", "Generator", "Literal", "Sized", "DefaultDict", "Container", "Writer", "SupportsBytes", "List", "assert_type", "Unpack", "Doc", "runtime_checkable", "NoReturn", "Union", "dataclass_transform", "cast", "Match", "Awaitable", "TypeForm", "Deque", "SupportsInt", "AsyncContextManager", "reveal_type", "Pattern", "ParamSpecKwargs", "Any", "ParamSpecArgs", "get_overloads", "AsyncGenerator", "TypeAlias", "TypeIs", "Iterable", "get_annotations", "evaluate_forward_ref", "AsyncIterable", "get_type_hints", "Required", "no_type_check", "MappingView", "TYPE_CHECKING", "Set", "deprecated", "IO", "Mapping", "TextIO", "Buffer", "get_protocol_members", "SupportsFloat", "runtime", "overload", "MutableSequence", "Coroutine", "Protocol", "Concatenate", "OrderedDict", "TypeVarTuple", "Type", "SupportsAbs", "TypeGuard", "Never", "LiteralString", "AbstractSet", "SupportsRound", "SupportsComplex", "ChainMap", "override", "no_type_check_decorator", "Optional", "Sentinel", "MutableSet", "NamedTuple", "Dict", "TypedDict"}, 117)
.PEP_560: {True}
.GenericMeta: {Type}
._PEP_696_IMPLEMENTED: Never
._FORWARD_REF_HAS_CLASS: Never
.Type__Sentinel: ClassType
.Type__Sentinel.__call__: () -> typing_extensions.Type__Sentinel
.Type__Sentinel.__repr__: (self: typing_extensions.Type__Sentinel) -> {"<sentinel>"}

typing_extensions = pyimport "typing_extensions"
._marker: .Type__Sentinel

._should_collect_from_parameters: (t: Obj) -> {t in Never}




.NoReturn: Never
.T: Never
.KT: Never
.VT: Never
.T_co: Never
.T_contra: Never

.___v_desugar_1: Never
.Any: Never

.Type__AnyMeta: ClassType
.Type__AnyMeta <: Never
.Type__AnyMeta.__instancecheck__: (self: typing_extensions.Type__AnyMeta, obj: Obj) -> Never
.Type__AnyMeta.__repr__: (self: typing_extensions.Type__AnyMeta) -> Never

.Any: ClassType



.ClassVar: Never
.Type__SpecialForm: ClassType
.Type__SpecialForm <: Never
.Type__SpecialForm.__doc__: Never
.Type__SpecialForm._getitem: Never
.Type__SpecialForm._name: Never
.Type__SpecialForm.__call__: (self: Obj, *args: Obj, **kwds := Obj) -> NoneType
.Type__SpecialForm.__slots__: global::Tuple([{"_name"}, {"__doc__"}, {"_getitem"}])
.Type__SpecialForm.__getattr__: (self: typing_extensions.Type__SpecialForm, item: Obj) -> Never
.Type__SpecialForm.__mro_entries__: (self: typing_extensions.Type__SpecialForm, bases: Obj) -> NoneType
.Type__SpecialForm.__repr__: (self: typing_extensions.Type__SpecialForm) -> Str
.Type__SpecialForm.__reduce__: (self: typing_extensions.Type__SpecialForm) -> Never
.Type__SpecialForm.__call__: (self: Obj, *args: Obj, **kwds := Obj) -> NoneType
.Type__SpecialForm.__or__: (self: typing_extensions.Type__SpecialForm, other: Obj) -> Never
.Type__SpecialForm.__ror__: (self: typing_extensions.Type__SpecialForm, other: Obj) -> Never
.Type__SpecialForm.__instancecheck__: (self: typing_extensions.Type__SpecialForm, obj: Obj) -> NoneType
.Type__SpecialForm.__subclasscheck__: (self: typing_extensions.Type__SpecialForm, cls: Obj) -> NoneType
.Type__SpecialForm.__getitem__: (self: typing_extensions.Type__SpecialForm, parameters: Obj) -> Never

.Type__ExtensionsSpecialForm: ClassType
.Type__ExtensionsSpecialForm <: Never
.Type__ExtensionsSpecialForm.__repr__: (self: typing_extensions.Type__ExtensionsSpecialForm) -> Str

.Final: Never

.final: Never




.IntVar: (name: Obj) -> Never

.Literal: Never

._flatten_literal_params: |T <: Structural({.__args__ = ?Type_2541}), Type_2541 <: global::Iterable(Obj), T <: Structural({.__args__ = ?Type_2541}), Type_2541 <: global::Iterable(Never)|(parameters: global::Iterable(T)) -> global::Tuple([T])
._value_and_type_iter: (params: global::Iterable(Never)) -> NoneType
._LiteralGenericAlias: ClassType

.Type__LiteralForm: ClassType
.Type__LiteralForm <: .Type__ExtensionsSpecialForm
.Type__LiteralForm._name: Never
.Type__LiteralForm.__call__: (doc: Str) -> typing_extensions.Type__LiteralForm
.Type__LiteralForm.__getitem__: (self: typing_extensions.Type__LiteralForm, parameters: global::Iterable(Structural({.__args__ = global::Iterable(Never)}))) -> Never

.Literal: .Type__LiteralForm


._overload_dummy: Never

.overload: Never
.get_overloads: Never
.clear_overloads: Never

._overload_registry: Never





.Type: Never
.Awaitable: Never
.Coroutine: Never
.AsyncIterable: Never
.AsyncIterator: Never
.Deque: Never
.DefaultDict: Never
.OrderedDict: Never
.Counter: Never
.ChainMap: Never
.Text: Never
.TYPE_CHECKING: Never

.___v_desugar_2: Never
.AsyncContextManager: Never
.AsyncGenerator: Never
.ContextManager: Never
.Generator: Never

._is_dunder: |Type_3026 <: Structural({.startswith = (self: Obj, ?3132) -> ?3133; .endswith = (self: Obj, ?3139) -> ?R}), Type_3133: Type, Type_3139: Type, R: Type, Type_3132: Type, O: Type|(attr: Type_3026) -> O
.Type__SpecialGenericAlias: ClassType
.Type__SpecialGenericAlias <: Never
.Type__SpecialGenericAlias._defaults: Never
.Type__SpecialGenericAlias.__call__: (origin: Obj, nparams: Obj, inst: Obj := Obj, name: Obj := Obj, defaults: Obj := Obj) -> typing_extensions.Type__SpecialGenericAlias
.Type__SpecialGenericAlias.__setattr__: |Type_3133 <: Structural({.__and__ = (self: Never, ?R) -> ?O}), Type_3132 :> {"__"}, Type_3139 :> {"__"}, R: Type, O: Type, T <: Structural({.startswith = (self: Obj, ?Type_3132) -> ?Type_3133; .endswith = (self: Obj, ?Type_3139) -> ?R})|(self: typing_extensions.Type__SpecialGenericAlias, attr: T, val: Obj) -> NoneType
.Type__SpecialGenericAlias.__getitem__: (self: typing_extensions.Type__SpecialGenericAlias, params: Obj) -> Never

._NoneType: Never
.Generator: Never
.AsyncGenerator: Never
.ContextManager: Never
.AsyncContextManager: Never


._PROTO_ALLOWLIST: global::Dict!({{"typing_extensions"}: global::List!({"Buffer"}, 1), {"collections.abc"}: global::List!({"Awaitable", "Iterator", "Container", "Callable", "Sized", "AsyncIterable", "Iterable", "Collection", "Buffer", "Hashable", "Reversible"}, 11), {"contextlib"}: global::List!({"AbstractContextManager", "AbstractAsyncContextManager"}, 2)})
._EXCLUDED_ATTRS: Never
._get_protocol_attrs: |Type_329 <: Structural({.__mro__ = ?3422}), Type_3422: Type|(cls: Type_329) -> Never
._caller: |R :> {1}, R: Type|(depth: Structural({.__add__ = (self: Never, R) -> Never and (self: Never, R) -> Never}) := {1} and Structural({.__add__ = (self: Never, R) -> Never and (self: Never, R) -> Never}), default: R := {"__main__"} and R) -> {None}

.Protocol: Never

._allow_reckless_class_checks: (depth: Structural({.__add__ = (self: Never, Obj) -> Never}) := {2} and Structural({.__add__ = (self: Never, Obj) -> Never})) -> Bool
._no_init: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
._type_check_issubclass_arg_1: (arg: Obj) -> NoneType
.Type__ProtocolMeta: ClassType
.Type__ProtocolMeta <: Never
.Type__ProtocolMeta.__call__: (cls: Obj, *args: Obj, **kwargs := Obj) -> typing_extensions.Type__ProtocolMeta
.Type__ProtocolMeta.__new__: |Type_3588 <: Structural({.__len__ = (self: Never) -> Nat})|(mcls: Obj, name: Obj, bases: Type_3588, namespace: Obj, **kwargs := Obj) -> Never
.Type__ProtocolMeta.__subclasscheck__: |Type_3934 <: global::Iterable(?T), T: Type, Type_3883: Type, Type_3592 <: Structural({.__dict__ = ?3883; .__non_callable_proto_members__ = ?3882 and ?3934}), Type_3882: Type|(cls: Type_3592, other: Obj) -> Never
.Type__ProtocolMeta.__instancecheck__: |Type_3595 <: Structural({.__protocol_attrs__ = ?4073; .__non_callable_proto_members__ = ?4087}), T: Type, Type_4073 <: global::Iterable(?T), Type_4087: Type|(cls: Type_3595, instance: Obj) -> {False}
.Type__ProtocolMeta.__eq__: (cls: Obj, other: Obj) -> Bool
.Type__ProtocolMeta.__hash__: (cls: Obj) -> Int

._proto_hook: |Type_383 <: Structural({.__protocol_attrs__ = ?4186}), Type_4186 <: global::Iterable(?T), T: Type|(cls: Type_383, other: Structural({.__mro__ = global::Iterable(Never)})) -> {True}
.Protocol: ClassType




.runtime_checkable: Never




.runtime: Never

.SupportsInt: Never
.SupportsFloat: Never
.SupportsComplex: Never
.SupportsBytes: Never
.SupportsIndex: Never
.SupportsAbs: Never
.SupportsRound: Never

.SupportsInt: ClassType

.SupportsFloat: ClassType

.SupportsComplex: ClassType

.SupportsBytes: ClassType

.SupportsIndex: ClassType

.SupportsAbs: ClassType

.SupportsRound: ClassType




.Reader: Never
.Writer: Never

.Reader: ClassType

.Writer: ClassType



._NEEDS_SINGLETONMETA: {typing in not Structural({.NoExtraItems = Obj}) or not Structural({.NoDefault = Obj})}

.SingletonMeta: ClassType
.SingletonMeta <: Never
.SingletonMeta.__setattr__: (cls: Obj, attr: Obj, value: Obj) -> NoneType




.NoDefault: Never

.NoDefaultType: ClassType
.NoDefaultType.__call__: () -> typing_extensions.NoDefaultType
.NoDefaultType.__slots__: global::Tuple([])
.NoDefaultType.__new__: (cls: Obj) -> Never
.NoDefaultType.__repr__: (self: typing_extensions.NoDefaultType) -> {"typing_extensions.NoDefault"}
.NoDefaultType.__reduce__: (self: typing_extensions.NoDefaultType) -> {"NoDefault"}

.NoDefault: .NoDefaultType




.NoExtraItems: Never

.NoExtraItemsType: ClassType
.NoExtraItemsType.__call__: () -> typing_extensions.NoExtraItemsType
.NoExtraItemsType.__slots__: global::Tuple([])
.NoExtraItemsType.__new__: (cls: Obj) -> Never
.NoExtraItemsType.__repr__: (self: typing_extensions.NoExtraItemsType) -> {"typing_extensions.NoExtraItems"}
.NoExtraItemsType.__reduce__: (self: typing_extensions.NoExtraItemsType) -> {"NoExtraItems"}

.NoExtraItems: .NoExtraItemsType







._PEP_728_IMPLEMENTED: {False}

.TypedDict: Never
._TypedDictMeta: Never
.is_typeddict: Never

._TAKES_MODULE: Never
._get_typeddict_qualifiers: (annotation_type: Obj) -> NoneType
._TypedDictMeta: ClassType

._TypedDict: Never
._create_typeddict: (typename: Obj, fields: Obj, typing_is_inline: Bool, total: Obj, closed: Obj, extra_items: Obj, **kwargs := Obj) -> Never
.Type__TypedDictSpecialForm: ClassType
.Type__TypedDictSpecialForm <: .Type__SpecialForm
.Type__TypedDictSpecialForm.__call__: (self: typing_extensions.Type__TypedDictSpecialForm, typename: Obj, fields: Obj := Obj, total: Obj := Obj, closed: Obj := Obj, extra_items: Obj := Obj, **kwargs := Obj) -> Never
.Type__TypedDictSpecialForm.__mro_entries__: (self: typing_extensions.Type__TypedDictSpecialForm, bases: Obj) -> global::Tuple([Never])


._TYPEDDICT_TYPES: Never




.assert_type: Never





.get_type_hints: Never

._strip_extras: |E: Type, Type_5222: Type, T: Type, Type_568 <: Structural({.__origin__ = ?5175 and ?T; .copy_with = (self: Obj, ?5274) -> ?5275; .__args__ = ?5222 and ?E}), Type_568 <: Structural({.__origin__ = ?5175 and ?T; .copy_with = (self: Never, ?5274) -> ?5275; .__args__ = ?5222 and ?E}), Type_5144: Type, Type_5274: Type, Type_5175 <: ?5144, Type_5275: Type|(t: Type_568) -> Type_568


._could_be_inserted_optional: |Type_5411: Type, Type_574 <: Structural({.__args__ = ?5411})|(t: Type_574) -> {True}
._clean_optional: |Type_576 <: Structural({.__dict__ = ?5646; .__annotations__ = ?5491}), Type_579 <: {_: ?579 and NoneType | _ == None}, Type_5646: Type, Type_5491: Type, Type_579: Type|(obj: Type_576, hints: Obj, globalns: Type_579 := Type_579, localns: Type_579 := Type_579) -> NoneType



.get_origin: Never
.get_args: Never






.TypeAlias: Never




._set_default: |Type_587: Type, Type_5769: Type, Type_586 <: Structural({.__default__ = ?587; .has_default = ?5769})|(type_param: Type_586, default: Type_587) -> NoneType
._set_module: (typevarlike: Obj) -> NoneType
.Type__DefaultMixin: ClassType
.Type__DefaultMixin.__call__: () -> typing_extensions.Type__DefaultMixin
.Type__DefaultMixin.__slots__: global::Tuple([])

.Type__TypeVarLikeMeta: ClassType
.Type__TypeVarLikeMeta <: Never
.Type__TypeVarLikeMeta.__instancecheck__: |Type_594 <: Structural({._backported_typevarlike = ?5810}), Type_5810 <: global::HomogenousTuple(ClassType) or ClassType|(cls: Type_594, __instance: Obj) -> Bool


.___v_desugar_3: Never
.TypeVar: Never

.TypeVar: ClassType




.ParamSpecArgs: Never
.ParamSpecKwargs: Never

.Type__Immutable: ClassType
.Type__Immutable.__call__: () -> typing_extensions.Type__Immutable
.Type__Immutable.__slots__: global::Tuple([])
.Type__Immutable.__copy__: |Type_5867 <: typing_extensions.Type__Immutable|(self: Type_5867) -> Type_5867
.Type__Immutable.__deepcopy__: |Type_5870 <: typing_extensions.Type__Immutable|(self: Type_5870, memo: Obj) -> Type_5870

.ParamSpecArgs: ClassType

.ParamSpecKwargs: ClassType




.___v_desugar_4: Never
.ParamSpec: Never


.ParamSpec: ClassType


.ParamSpec: ClassType







._type_convert: |Type_721: Type|(arg: Type_721, module: Obj := Obj, allow_special_forms: Obj := Obj) -> Type_721

._type_convert: Never


.Type__ConcatenateGenericAlias: ClassType
.Type__ConcatenateGenericAlias <: global::GenericList
.Type__ConcatenateGenericAlias.__origin__: Never
.Type__ConcatenateGenericAlias.__args__: Never
.Type__ConcatenateGenericAlias.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
.Type__ConcatenateGenericAlias.__class__: Never
.Type__ConcatenateGenericAlias.__repr__: (self: typing_extensions.Type__ConcatenateGenericAlias) -> Str
.Type__ConcatenateGenericAlias.__hash__: (self: typing_extensions.Type__ConcatenateGenericAlias) -> Int
.Type__ConcatenateGenericAlias.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> NoneType
.Type__ConcatenateGenericAlias.__parameters__ : (self: typing_extensions.Type__ConcatenateGenericAlias) -> global::Tuple([Never])
.Type__ConcatenateGenericAlias.__parameters__: Never
.Type__ConcatenateGenericAlias.copy_with: (self: typing_extensions.Type__ConcatenateGenericAlias, params: typing_extensions.Type__SpecialForm or typing_extensions.Type__LiteralForm or typing_extensions.Type__SpecialGenericAlias) -> Never
.Type__ConcatenateGenericAlias.__getitem__: (self: typing_extensions.Type__ConcatenateGenericAlias, args: global::List!(Obj, 2)) -> Never


.Type__ConcatenateGenericAlias: Never

.Type__ConcatenateGenericAlias: ClassType
.Type__ConcatenateGenericAlias <: global::GenericList
.Type__ConcatenateGenericAlias.__origin__: Never
.Type__ConcatenateGenericAlias.__args__: Never
.Type__ConcatenateGenericAlias.__module__: {"typing"}
.Type__ConcatenateGenericAlias.copy_with: (self: typing_extensions.Type__ConcatenateGenericAlias, params: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm) -> Never
.Type__ConcatenateGenericAlias.__getitem__: (self: typing_extensions.Type__ConcatenateGenericAlias, args: Obj) -> Never





.Type__EllipsisDummy: ClassType
.Type__EllipsisDummy.__call__: () -> typing_extensions.Type__EllipsisDummy

._create_concatenate_alias: (origin: Obj, parameters: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm) -> Never
._concatenate_getitem: |E <: Structural({.__getitem__ = (self: Obj, ?R) -> ?7307 and (self: Obj, ?R) -> ?7299}), Type_7299: Type, Type_7307: Type, R: Type|(self: Obj, parameters: E) -> Never

.Concatenate: Never





.TypeGuard: Never





.TypeIs: Never





.TypeForm: Never

.Type__TypeFormForm: ClassType
.Type__TypeFormForm <: .Type__ExtensionsSpecialForm
.Type__TypeFormForm.__call__: |Type_7442: Type|(self: typing_extensions.Type__TypeFormForm, obj: Type_7442) -> Type_7442





.LiteralString: Never





.Self: Never





.Never: Never





.Required: Never
.NotRequired: Never






.ReadOnly: Never




._UNPACK_DOC: {"Type unpack operator.\n\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and \'pulls them out\'. For\nexample:\n\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n\n  Ts = TypeVarTuple(\'Ts\')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual\n  #  `TypeVar`s, which the `Unpack` is \'pulling out\' directly into the\n  #  `Generic[]`.)\n  class Bar(Generic[Unpack[Ts]]): ...\n  Bar[int]  # Valid\n  Bar[int, str]  # Also valid\n\nFrom Python 3.11, this can also be done using the `*` operator:\n\n    Foo[*tuple[int, str]]\n    class Bar(Generic[*Ts]): ...\n\nThe operator can also be used along with a `TypedDict` to annotate\n`**kwargs` in a function signature. For instance:\n\n  class Movie(TypedDict):\n    name: str\n    year: int\n\n  # This function expects two keyword arguments - *name* of type `str` and\n  # *year* of type `int`.\n  def foo(**kwargs: Unpack[Movie]): ...\n\nNote that there is only some runtime checking of this operator. Not\neverything the runtime allows may be accepted by static type checkers.\n\nFor more information, see PEP 646 and PEP 692.\n"}

.Unpack: Never
._is_unpack: Never

.Type__UnpackSpecialForm: ClassType
.Type__UnpackSpecialForm <: .Type__ExtensionsSpecialForm
.Type__UnpackSpecialForm.__doc__: Never
.Type__UnpackSpecialForm.__call__: (getitem: Obj) -> typing_extensions.Type__UnpackSpecialForm

.Type__UnpackAlias: ClassType
.Type__UnpackAlias <: Never
.Type__UnpackAlias.__typing_unpacked_tuple_args__ : (self: typing_extensions.Type__UnpackAlias) -> {None}
.Type__UnpackAlias.__typing_unpacked_tuple_args__: {None}
.Type__UnpackAlias.__typing_is_unpacked_typevartuple__ : (self: typing_extensions.Type__UnpackAlias) -> {.self.__args__.__getitem__(0) in Never}
.Type__UnpackAlias.__typing_is_unpacked_typevartuple__: {.self.__args__.__getitem__(0) in Never}
.Type__UnpackAlias.__getitem__: (self: typing_extensions.Type__UnpackAlias, args: Obj) -> Never





._unpack_args: (*args: Obj) -> global::List!(Never, 2)

.___v_desugar_5: Never
.TypeVarTuple: Never


.TypeVarTuple: ClassType


.TypeVarTuple: ClassType






.reveal_type: Never





._ASSERT_NEVER_REPR_MAX_LENGTH: Never

._ASSERT_NEVER_REPR_MAX_LENGTH: Never



.assert_never: Never





.dataclass_transform: Never





.override: Never

._F: Never




.deprecated: Never

._T: Never
.deprecated: ClassType




._is_param_expr: (arg: Obj) -> {arg in {Ellipsis} or global::List(Obj, _: Nat) or global::HomogenousTuple(Obj)}





._check_generic: |Type_1121 <: Structural({.__len__ = (self: Never) -> Nat; .__getitem__ = (self: Obj, ?8126) -> ?8127}), Type_8126: Type, Type_8127: Type|(cls: Never, parameters: Type_1121, elen: Bool := typing_extensions.Type__Sentinel and Bool) -> NoneType








._has_generic_or_protocol_as_origin: () -> Bool
._TYPEVARTUPLE_TYPES: global::Set!({None} or ClassType, _: Nat)
._is_unpacked_typevartuple: (x: Obj) -> Bool

._collect_type_vars: |T: Type, T <: Structural({.__parameters__ = ?Type_8473}), Type_8473 <: global::Iterable(?T)|(types: global::Iterable(T), typevar_types: global::HomogenousTuple(ClassType) or ClassType := global::HomogenousTuple(ClassType) or ClassType) -> global::Tuple([T])


._collect_parameters: (args: global::Iterable(Obj)) -> global::Tuple([Obj])







.NamedTuple: Never

._make_nmtuple: (name: Obj, types: Obj, module: Obj, defaults: Obj := Obj) -> Never
._prohibited_namedtuple_fields: Never
._special_namedtuple_fields: global::FrozenSet({"__name__", "__annotations__", "__module__"})
.Type__NamedTupleMeta: ClassType
.Type__NamedTupleMeta <: Never
.Type__NamedTupleMeta.__new__: |Type_8824 :> global::Tuple([?T]), Type_8824 <: Structural({.__contains__ = (self: Never, ?T) -> Bool}), T <: typing_extensions.Type__SpecialForm or typing_extensions.Type__ConcatenateGenericAlias or typing_extensions.Type__UnpackAlias or typing_extensions.Type__SpecialGenericAlias or typing_extensions.Type__LiteralForm, T: Type|(cls: Obj, typename: Obj, bases: Type_8824, ns: Structural({.items = (self: Obj) -> global::Iterable(T); .__contains__ = (self: Never, Obj) -> Bool; .__getitem__ = (self: Obj, Obj) -> global::Dict!({Never: Never}) and (self: Obj, Obj) -> ({1}) -> global::Dict!({Never: Never})})) -> Never

._NamedTuple: Never
._namedtuple_mro_entries: |Type_1190 <: Structural({.__contains__ = (self: Never, ?R) -> Bool and (self: Never, ?R) -> Bool}), R: Type|(bases: Type_1190) -> global::Tuple([Never])





.Buffer: Never

.Buffer: ClassType







.get_original_bases: Never





.NewType: Never

.NewType: ClassType




.TypeAliasType: Never


._is_unionable: (obj: Obj) -> {obj in {None} or Type}





._ATTRIBUTE_DELEGATION_EXCLUSIONS: global::FrozenSet({"__parameters__", "__copy__", "__class__", "__deepcopy__", "__args__", "__reduce_ex__", "__unpacked__", "__origin__", "__mro_entries__", "__typing_unpacked_tuple_args__", "__reduce__", "__bases__"})
.Type__TypeAliasGenericAlias: ClassType
.Type__TypeAliasGenericAlias <: Never
.Type__TypeAliasGenericAlias.__getattr__: (self: typing_extensions.Type__TypeAliasGenericAlias, attr: Str) -> Obj



.TypeAliasType: ClassType




.is_protocol: Never
.get_protocol_members: Never






.Doc: Never

.Doc: ClassType



._CapsuleType: {None}

._socket: Never


._CAPI: {None}








.CapsuleType: Never




.___v_desugar_7: Never
.Format: Never
.get_annotations: Never

.Format: ClassType





.evaluate_forward_ref: Never

._eval_with_owner: |Type_9408: Type, Type_9407 <: Bool, Type_1440 <: Structural({.__forward_value__ = ?9408 and ?9419; .__forward_module__ = ?9435; .__forward_evaluated__ = ?9407 and ?9418; .__forward_code__ = ?9689; .__forward_is_class__ = ?R; .__forward_arg__ = ?R; .__cell__ = ?9416}), Type_9418: Type, Type_9435 <: Ref(Obj), Type_9419: Type, R: Type, Type_9689: Type, Type_9416: Type|(forward_ref: Type_1440, owner: Obj := Obj, globals: NoneType := NoneType, locals: global::Dict({global::Tuple([Obj, Never]): Never}) := global::Dict({global::Tuple([Obj, Never]): Never}), type_params: Obj := Obj) -> Never



.Sentinel: ClassType
.Sentinel._name: Never
.Sentinel._repr: Never
.Sentinel.__call__: (name: Str, repr: NoneType or Str := NoneType or Str) -> typing_extensions.Sentinel
.Sentinel.__repr__: (self: typing_extensions.Sentinel) -> Never
.Sentinel.__getstate__: (self: typing_extensions.Sentinel) -> NoneType

._typing_names: global::List!({"MutableMapping", "ItemsView", "Mapping", "Container", "Sequence", "Dict", "Reversible", "no_type_check_decorator", "_AnnotatedAlias", "KeysView", "Callable", "Match", "MutableSequence", "Set", "TextIO", "IO", "MutableSet", "Tuple", "FrozenSet", "Iterator", "MappingView", "BinaryIO", "ValuesView", "no_type_check", "Hashable", "List", "Iterable", "cast", "Optional", "AnyStr", "AbstractSet", "Collection", "Pattern", "Union", "Sized"}, 35)

.Generic: Never
.ForwardRef: Never
.Annotated: Never
