##[pylyzer] failed /home/ether/Desktop/testingThings/realstate/activate/lib/python3.11/site-packages/click/shell_completion.py 1753141474 19857
.___v_desugar_1: Never
.annotations: Never
.cabc: Never

.os: Never

.re: Never

.t: Never

.___v_desugar_2: Never
._: Never
.___v_desugar_3 = pyimport "core"
.core = pyimport "core"
.Argument: {core.Argument}
.___v_desugar_4 = pyimport "core"

.Command: {core.Command}
.___v_desugar_5 = pyimport "core"

.Context: {core.Context}
.___v_desugar_6 = pyimport "core"

.Group: {core.Group}
.___v_desugar_7 = pyimport "core"

.Option: {core.Option}
.___v_desugar_8 = pyimport "core"

.Parameter: {core.Parameter}
.___v_desugar_9 = pyimport "core"

.ParameterSource: {core.ParameterSource}
.___v_desugar_10 = pyimport "utils"
.utils = pyimport "utils"
.echo: (message: Obj := Obj, file: NoneType := NoneType, nl: Bool := Bool, err: Bool := Bool, color: NoneType or Bool := NoneType or Bool) -> NoneType
.shell_complete: (cli: core.Command, ctx_args: Obj, prog_name: Str, complete_var: Str, instruction: Str) -> Int
.CompletionItem: ClassType
.CompletionItem._info: Never
.CompletionItem.value: Never
.CompletionItem.help: NoneType or Str
.CompletionItem.type: Str
.CompletionItem.__call__: (value: Obj, Type: Str := Str, help: NoneType or Str := NoneType or Str, **kwargs := Obj) -> shell_completion.CompletionItem
.CompletionItem.__slots__: global::Tuple([{"value"}, {"type"}, {"help"}, {"_info"}])
.CompletionItem.__getattr__: (self: shell_completion.CompletionItem, name: Str) -> Never

._SOURCE_BASH: {"Type_(complete_func)s() {\n    local IFS=$\'\\n\'\n    local response\n\n    response=$(env COMP_WORDS=\"${COMP_WORDS[*]}\" COMP_CWORD=$COMP_CWORD Type_(complete_var)s=bash_complete $1)\n\n    for completion in $response; do\n        IFS=\',\' read type value <<< \"$completion\"\n\n        if [[ $type == \'dir\' ]]; then\n            COMPREPLY=()\n            compopt -o dirnames\n        elif [[ $type == \'file\' ]]; then\n            COMPREPLY=()\n            compopt -o default\n        elif [[ $type == \'plain\' ]]; then\n            COMPREPLY+=($value)\n        fi\n    done\n\n    return 0\n}\n\nType_(complete_func)s_setup() {\n    complete -o nosort -F Type_(complete_func)s Type_(prog_name)s\n}\n\nType_(complete_func)s_setup;\n"}
._SOURCE_ZSH: {"#compdef Type_(prog_name)s\n\nType_(complete_func)s() {\n    local -a completions\n    local -a completions_with_descriptions\n    local -a response\n    (( ! $+commands[Type_(prog_name)s] )) && return 1\n\n    response=(\"${(@f)$(env COMP_WORDS=\"${words[*]}\" COMP_CWORD=$((CURRENT-1)) Type_(complete_var)s=zsh_complete Type_(prog_name)s)}\")\n\n    for type key descr in ${response}; do\n        if [[ \"$type\" == \"plain\" ]]; then\n            if [[ \"$descr\" == \"_\" ]]; then\n                completions+=(\"$key\")\n            else\n                completions_with_descriptions+=(\"$key\":\"$descr\")\n            fi\n        elif [[ \"$type\" == \"dir\" ]]; then\n            _path_files -.\n        elif [[ \"$type\" == \"file\" ]]; then\n            _path_files -f\n        fi\n    done\n\n    if [ -n \"$completions_with_descriptions\" ]; then\n        _describe -V unsorted completions_with_descriptions -U\n    fi\n\n    if [ -n \"$completions\" ]; then\n        compadd -U -V unsorted -a completions\n    fi\n}\n\nif [[ $zsh_eval_context[-1] == loadautofunc ]]; then\n    # autoload from fpath, call function directly\n    Type_(complete_func)s \"$@\"\nelse\n    # eval.source.. command, register function for later\n    compdef Type_(complete_func)s Type_(prog_name)s\nfi\n"}
._SOURCE_FISH: {"function Type_(complete_func)s;\n    set -l response (env Type_(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) COMP_CWORD=(commandline -t) Type_(prog_name)s);\n\n    for completion in $response;\n        set -l metadata (string split \",\" $completion);\n\n        if test $metadata[1] = \"dir\";\n            __fish_complete_directories $metadata[2];\n        else if test $metadata[1] = \"file\";\n            __fish_complete_path $metadata[2];\n        else if test $metadata[1] = \"plain\";\n            echo $metadata[2];\n        end;\n    end;\nend;\n\ncomplete --no-files --command Type_(prog_name)s --arguments \"(Type_(complete_func)s)\";\n"}
.ShellComplete: ClassType
.ShellComplete.source_template: Never
.ShellComplete.ctx_args: Never
.ShellComplete.complete_var: Str
.ShellComplete.name: Never
.ShellComplete.cli: core.Command
.ShellComplete.prog_name: Str
.ShellComplete.__call__: (cli: core.Command, ctx_args: Obj, prog_name: Str, complete_var: Str) -> shell_completion.ShellComplete
.ShellComplete.func_name : (self: shell_completion.ShellComplete) -> Str
.ShellComplete.func_name: Str
.ShellComplete.source_vars: Never
.ShellComplete.source: (self: shell_completion.ShellComplete) -> Str
.ShellComplete.get_completion_args: (self: shell_completion.ShellComplete) -> global::Tuple([global::List!(Str, _: Nat), Str])
.ShellComplete.get_completions: (self: shell_completion.ShellComplete, args: global::List!(Str, _: Nat), incomplete: Str) -> global::List!(shell_completion.CompletionItem, _: Nat)
.ShellComplete.format_completion: (self: shell_completion.ShellComplete, item: shell_completion.CompletionItem) -> Str
.ShellComplete.complete: (self: shell_completion.ShellComplete) -> Str

.BashComplete: ClassType
shell_completion = pyimport "shell_completion"
.BashComplete <: .ShellComplete
.BashComplete.name: {"bash"}
.BashComplete.source_template: {"Type_(complete_func)s() {\n    local IFS=$\'\\n\'\n    local response\n\n    response=$(env COMP_WORDS=\"${COMP_WORDS[*]}\" COMP_CWORD=$COMP_CWORD Type_(complete_var)s=bash_complete $1)\n\n    for completion in $response; do\n        IFS=\',\' read type value <<< \"$completion\"\n\n        if [[ $type == \'dir\' ]]; then\n            COMPREPLY=()\n            compopt -o dirnames\n        elif [[ $type == \'file\' ]]; then\n            COMPREPLY=()\n            compopt -o default\n        elif [[ $type == \'plain\' ]]; then\n            COMPREPLY+=($value)\n        fi\n    done\n\n    return 0\n}\n\nType_(complete_func)s_setup() {\n    complete -o nosort -F Type_(complete_func)s Type_(prog_name)s\n}\n\nType_(complete_func)s_setup;\n"}
.BashComplete._check_version: () -> NoneType
.BashComplete.source: (self: shell_completion.BashComplete) -> Str
.BashComplete.get_completion_args: (self: shell_completion.BashComplete) -> global::Tuple([global::List!(Str, _: Nat), Str])
.BashComplete.format_completion: (self: shell_completion.BashComplete, item: shell_completion.CompletionItem) -> Str

.ZshComplete: ClassType
.ZshComplete <: .ShellComplete
.ZshComplete.name: {"zsh"}
.ZshComplete.source_template: {"#compdef Type_(prog_name)s\n\nType_(complete_func)s() {\n    local -a completions\n    local -a completions_with_descriptions\n    local -a response\n    (( ! $+commands[Type_(prog_name)s] )) && return 1\n\n    response=(\"${(@f)$(env COMP_WORDS=\"${words[*]}\" COMP_CWORD=$((CURRENT-1)) Type_(complete_var)s=zsh_complete Type_(prog_name)s)}\")\n\n    for type key descr in ${response}; do\n        if [[ \"$type\" == \"plain\" ]]; then\n            if [[ \"$descr\" == \"_\" ]]; then\n                completions+=(\"$key\")\n            else\n                completions_with_descriptions+=(\"$key\":\"$descr\")\n            fi\n        elif [[ \"$type\" == \"dir\" ]]; then\n            _path_files -.\n        elif [[ \"$type\" == \"file\" ]]; then\n            _path_files -f\n        fi\n    done\n\n    if [ -n \"$completions_with_descriptions\" ]; then\n        _describe -V unsorted completions_with_descriptions -U\n    fi\n\n    if [ -n \"$completions\" ]; then\n        compadd -U -V unsorted -a completions\n    fi\n}\n\nif [[ $zsh_eval_context[-1] == loadautofunc ]]; then\n    # autoload from fpath, call function directly\n    Type_(complete_func)s \"$@\"\nelse\n    # eval.source.. command, register function for later\n    compdef Type_(complete_func)s Type_(prog_name)s\nfi\n"}
.ZshComplete.get_completion_args: (self: shell_completion.ZshComplete) -> global::Tuple([global::List!(Str, _: Nat), Str])
.ZshComplete.format_completion: (self: shell_completion.ZshComplete, item: shell_completion.CompletionItem) -> Str

.FishComplete: ClassType
.FishComplete <: .ShellComplete
.FishComplete.name: {"fish"}
.FishComplete.source_template: {"function Type_(complete_func)s;\n    set -l response (env Type_(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) COMP_CWORD=(commandline -t) Type_(prog_name)s);\n\n    for completion in $response;\n        set -l metadata (string split \",\" $completion);\n\n        if test $metadata[1] = \"dir\";\n            __fish_complete_directories $metadata[2];\n        else if test $metadata[1] = \"file\";\n            __fish_complete_path $metadata[2];\n        else if test $metadata[1] = \"plain\";\n            echo $metadata[2];\n        end;\n    end;\nend;\n\ncomplete --no-files --command Type_(prog_name)s --arguments \"(Type_(complete_func)s)\";\n"}
.FishComplete.get_completion_args: (self: shell_completion.FishComplete) -> global::Tuple([global::List!(Str, _: Nat), Str])
.FishComplete.format_completion: (self: shell_completion.FishComplete, item: shell_completion.CompletionItem) -> Str

.ShellCompleteType: Never
._available_shells: global::Dict!({Str: (Type).__getitem__(shell_completion.ShellComplete)})
.add_completion_class: (cls: Obj, name: NoneType or Str := NoneType or Str) -> Never
.get_completion_class: (shell: Str) -> NoneType
.split_arg_string: (string: Str) -> global::List!(Str, _: Nat)
._is_incomplete_argument: (ctx: core.Context, param: core.Parameter) -> Bool
._start_of_option: (ctx: core.Context, value: Str) -> Bool
._is_incomplete_option: (ctx: core.Context, args: global::List!(Str, _: Nat), param: core.Parameter) -> Bool
._resolve_context: (cli: core.Command, ctx_args: global::Dict!({{"resilient_parsing"}: {True}}), prog_name: Str, args: global::List!(Str, _: Nat)) -> core.Context
._resolve_incomplete: (ctx: core.Context, args: global::List!(Str, _: Nat), incomplete: Str) -> global::Tuple([core.Parameter or core.Command, Str])
