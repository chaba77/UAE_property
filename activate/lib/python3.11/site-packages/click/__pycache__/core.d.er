##[pylyzer] failed /home/ether/Desktop/testingThings/realstate/activate/lib/python3.11/site-packages/click/core.py 1753141474 117343
.___v_desugar_1: Never
.annotations: Never
.cabc: Never

.enum: Never

.errno: Never

.inspect: Never

.os: Never

.sys: Never

.t: Never

.___v_desugar_2: Never
.abc: Never
.___v_desugar_3: Never
.Counter: Never
.___v_desugar_4: Never
.AbstractContextManager: Never
.___v_desugar_5: Never
.contextmanager: Never
.___v_desugar_6: Never
.ExitStack: Never
.___v_desugar_7: Never
.update_wrapper: Never
.___v_desugar_8: Never
._: Never
.___v_desugar_9: Never
.ngettext: Never
.___v_desugar_10: Never
.repeat: Never
.___v_desugar_11 = pyimport "types"
.types = pyimport "types"
.TracebackType: Never
.___v_desugar_12 = pyimport "__init__"
.__init__ = pyimport "__init__"
.types: Never
.___v_desugar_13 = pyimport "exceptions"
.exceptions = pyimport "exceptions"
.Abort: Never
.___v_desugar_14 = pyimport "exceptions"

.BadParameter: Never
.___v_desugar_15 = pyimport "exceptions"

.ClickException: Never
.___v_desugar_16 = pyimport "exceptions"

.Exit: Never
.___v_desugar_17 = pyimport "exceptions"

.MissingParameter: Never
.___v_desugar_18 = pyimport "exceptions"

.NoArgsIsHelpError: Never
.___v_desugar_19 = pyimport "exceptions"

.UsageError: Never
.___v_desugar_20 = pyimport "formatting"
.formatting = pyimport "formatting"
.HelpFormatter: Never
.___v_desugar_21 = pyimport "formatting"

.join_options: (options: global::Iterable(Str)) -> global::Tuple([Str, Bool])
.___v_desugar_22 = pyimport "globals"
.globals = pyimport "globals"
.pop_context: () -> NoneType
.___v_desugar_23 = pyimport "globals"

.push_context: (ctx: core.Context) -> NoneType
.___v_desugar_24 = pyimport "parser"
.parser = pyimport "parser"
._flag_needs_value: Obj
.___v_desugar_25 = pyimport "parser"

._OptionParser: Never
.___v_desugar_26 = pyimport "parser"

._split_opt: (opt: Str) -> global::Tuple([Str, Str])
.___v_desugar_27 = pyimport "termui"
.termui = pyimport "termui"
.confirm: (text: Str, default: NoneType or Bool := NoneType or Bool, abort: Bool := Bool, prompt_suffix: Str := Str, show_default: Bool := Bool, err: Bool := Bool) -> Bool
.___v_desugar_28 = pyimport "termui"

.prompt: (text: Str, default: Obj := Obj, hide_input: Bool := Bool, confirmation_prompt: Bool or Str := Bool or Str, Type: Obj := Obj, value_proc: Obj := Obj, prompt_suffix: Str := Str, show_default: Bool := Bool, err: Bool := Bool, show_choices: Bool := Bool) -> Never
.___v_desugar_29 = pyimport "termui"

.style: (text: Obj, fg: global::Tuple([Int, Int, Int]) or NoneType or Str or Int := global::Tuple([Int, Int, Int]) or NoneType or Str or Int, bg: global::Tuple([Int, Int, Int]) or NoneType or Str or Int := global::Tuple([Int, Int, Int]) or NoneType or Str or Int, bold: NoneType or Bool := NoneType or Bool, dim: NoneType or Bool := NoneType or Bool, underline: NoneType or Bool := NoneType or Bool, overline: NoneType or Bool := NoneType or Bool, italic: NoneType or Bool := NoneType or Bool, blink: NoneType or Bool := NoneType or Bool, reverse: NoneType or Bool := NoneType or Bool, strikethrough: NoneType or Bool := NoneType or Bool, reset: Bool := Bool) -> Str
.___v_desugar_30 = pyimport "utils"
.utils = pyimport "utils"
._detect_program_name: (path: NoneType or Str := NoneType or Str, _main: Obj := Obj) -> Str
.___v_desugar_31 = pyimport "utils"

._expand_args: (args: global::Iterable(Str), user: Bool := Bool, env: Bool := Bool, glob_recursive: Bool := Bool) -> global::List!(Str, _: Nat)
.___v_desugar_32 = pyimport "utils"

.echo: (message: Obj := Obj, file: NoneType := NoneType, nl: Bool := Bool, err: Bool := Bool, color: NoneType or Bool := NoneType or Bool) -> NoneType
.___v_desugar_33 = pyimport "utils"

.make_default_short_help: (help: Str, max_length: Int := Int) -> Str
.___v_desugar_34 = pyimport "utils"

.make_str: (value: Obj) -> Str
.___v_desugar_35 = pyimport "utils"

.PacifyFlushWrapper: Never

.___v_desugar_36 = pyimport "shell_completion"
.shell_completion = pyimport "shell_completion"
.CompletionItem: {shell_completion.CompletionItem}


.F: Never
.V: Never
._complete_visible_commands: (ctx: Obj, incomplete: Str) -> NoneType
._check_nested_chain: (base_command: Obj, cmd_name: Str, cmd: Obj, register: Bool := Bool) -> NoneType
.batch: Never
.augment_usage_errors: (ctx: Obj, param: Obj := Obj) -> Never
.iter_params_for_processing: ||Never
.ParameterSource: ClassType
.ParameterSource <: Never
.ParameterSource.COMMANDLINE: Never
.ParameterSource.ENVIRONMENT: Never
.ParameterSource.DEFAULT: Never
.ParameterSource.DEFAULT_MAP: Never
.ParameterSource.PROMPT: Never

.Context: ClassType
.Context._meta: global::Dict!({Str: Never})
.Context.default_map: Never
.Context.allow_extra_args: NoneType or Bool
.Context.show_default: NoneType or Bool
.Context.parent: Never
.Context.args: global::List!(Str, _: Nat)
.Context._opt_prefixes: Never
.Context.max_content_width: NoneType or Int
.Context._protected_args: global::List!(Str, _: Nat)
.Context.invoked_subcommand: NoneType or Str
.Context._depth: Never
.Context.help_option_names: global::List!(Str, _: Nat) or NoneType
.Context.resilient_parsing: Bool
.Context.color: NoneType or Bool
.Context._exit_stack: Never
.Context.ignore_unknown_options: NoneType or Bool
.Context.params: global::Dict!({Str: Never})
.Context.allow_interspersed_args: NoneType or Bool
.Context.command: Never
.Context.info_name: NoneType or Str
.Context.auto_envvar_prefix: NoneType or Str
.Context._close_callbacks: global::List!(Never, _: Nat)
.Context.obj: Never
.Context.token_normalize_func: Never
.Context._parameter_source: global::Dict!({Str: core.ParameterSource})
.Context.terminal_width: NoneType or Int
.Context.__call__: (command: Obj, parent: core.Context or NoneType := core.Context or NoneType, info_name: NoneType or Str := NoneType or Str, obj: Obj := Obj, auto_envvar_prefix: NoneType or Str := NoneType or Str, default_map: Obj := Obj, terminal_width: NoneType or Int := NoneType or Int, max_content_width: NoneType or Int := NoneType or Int, resilient_parsing: Bool := Bool, allow_extra_args: NoneType or Bool := NoneType or Bool, allow_interspersed_args: NoneType or Bool := NoneType or Bool, ignore_unknown_options: NoneType or Bool := NoneType or Bool, help_option_names: NoneType or global::List!(Str, _: Nat) := NoneType or global::List!(Str, _: Nat), token_normalize_func: Obj := Obj, color: NoneType or Bool := NoneType or Bool, show_default: NoneType or Bool := NoneType or Bool) -> core.Context
.Context.formatter_class: Never
.Context.protected_args : (self: core.Context) -> global::List!(Str, _: Nat)
.Context.protected_args: global::List!(Str, _: Nat)
.Context.to_info_dict: Never
.Context.__enter__: (self: core.Context) -> core.Context
.Context.__exit__: (self: core.Context, exc_type: Obj, exc_value: global::BaseException or NoneType, tb: Obj) -> NoneType
.Context.scope: (self: core.Context, cleanup: Bool := Bool) -> Never
.Context.meta : Never
.Context.meta: Never
.Context.make_formatter: (self: core.Context) -> Never
.Context.with_resource: (self: core.Context, context_manager: Obj) -> Never
.Context.call_on_close: (self: core.Context, f: Obj) -> Never
.Context.close: (self: core.Context) -> NoneType
.Context.command_path : (self: core.Context) -> Str
.Context.command_path: Str
.Context.find_root: (self: core.Context) -> core.Context
.Context.find_object: (self: core.Context, object_type: global::HomogenousTuple(ClassType) or ClassType) -> Never
.Context.ensure_object: (self: core.Context, object_type: () -> {None}) -> Never
.Context.lookup_default: (self: core.Context, name: Str, call: Obj := Obj) -> Never
.Context.lookup_default: (self: core.Context, name: Str, call: Obj := Obj) -> Never
.Context.lookup_default: (self: core.Context, name: Str, call: Bool := Bool) -> Never
.Context.fail: (self: core.Context, message: Str) -> Never
.Context.abort: (self: core.Context) -> Never
.Context.exit: (self: core.Context, code: Int := Int and Int) -> Never
.Context.get_usage: (self: core.Context) -> Str
.Context.get_help: (self: core.Context) -> Str
.Context._make_sub_context: (self: core.Context, command: Obj) -> core.Context
.Context.invoke: (self: core.Context, callback: Obj, *args: Obj, **kwargs := Obj) -> Never
.Context.invoke: (self: core.Context, callback: Obj, *args: Obj, **kwargs := Obj) -> Never
.Context.invoke: (self: core.Context, callback: Obj, *args: Obj, **kwargs := Obj) -> Never
.Context.forward: (self: core.Context, cmd: Obj, *args: Obj, **kwargs := Obj) -> Never
.Context.set_parameter_source: (self: core.Context, name: Str, source: core.ParameterSource) -> NoneType
.Context.get_parameter_source: (self: core.Context, name: Str) -> NoneType or core.ParameterSource

.Command: ClassType
.Command.context_settings: Never
.Command.add_help_option: Bool
.Command.help: NoneType or Str
.Command.epilog: NoneType or Str
.Command.params: global::List!(Never, _: Nat)
.Command.short_help: NoneType or Str
.Command.options_metavar: NoneType or Str
.Command._help_option: Never
.Command.name: NoneType or Str
.Command.deprecated: Bool or Str
.Command.callback: Never
.Command.no_args_is_help: Bool
.Command.hidden: Bool
.Command.__call__: (self: NoneType or Str, *args: Obj, **kwargs := Obj) -> Never
.Command.context_class: Never
.Command.allow_extra_args: {False}
.Command.allow_interspersed_args: {True}
.Command.ignore_unknown_options: {False}
.Command.to_info_dict: Never
.Command.__repr__: (self: core.Command) -> Str
.Command.get_usage: (self: core.Command, ctx: core.Context) -> Str
.Command.get_params: Never
.Command.format_usage: (self: core.Command, ctx: core.Context, formatter: Obj) -> NoneType
.Command.collect_usage_pieces: (self: core.Command, ctx: core.Context) -> global::List!(Str, _: Nat)
.Command.get_help_option_names: (self: core.Command, ctx: core.Context) -> global::List!(Str, _: Nat)
.Command.get_help_option: (self: core.Command, ctx: core.Context) -> Never
.Command.make_parser: (self: core.Command, ctx: core.Context) -> Never
.Command.get_help: (self: core.Command, ctx: core.Context) -> Str
.Command.get_short_help_str: (self: core.Command, limit: Int := Int) -> Str
.Command.format_help: (self: core.Command, ctx: core.Context, formatter: Obj) -> NoneType
.Command.format_help_text: (self: core.Command, ctx: core.Context, formatter: Obj) -> NoneType
.Command.format_options: (self: core.Command, ctx: core.Context, formatter: Obj) -> NoneType
.Command.format_epilog: (self: core.Command, ctx: core.Context, formatter: Obj) -> NoneType
.Command.make_context: (self: core.Command, info_name: NoneType or Str, args: global::List!(Str, _: Nat), parent: core.Context or NoneType := {None} and core.Context or NoneType, **extra := Obj) -> core.Context
.Command.parse_args: (self: core.Command, ctx: core.Context, args: global::List!(Str, _: Nat)) -> global::List!(Str, _: Nat)
.Command.invoke: (self: core.Command, ctx: core.Context) -> Never
.Command.shell_complete: Never
.Command.main: (self: core.Command, args: Obj := Obj, prog_name: NoneType or Str := NoneType or Str, complete_var: NoneType or Str := NoneType or Str, standalone_mode: Obj := Obj, **extra := Obj) -> Never
.Command.main: (self: core.Command, args: Obj := Obj, prog_name: NoneType or Str := NoneType or Str, complete_var: NoneType or Str := NoneType or Str, standalone_mode: Bool := Bool, **extra := Obj) -> Never
.Command.main: (self: core.Command, args: NoneType := NoneType, prog_name: NoneType or Str := NoneType or Str, complete_var: NoneType or Str := NoneType or Str, standalone_mode: Bool := Bool, windows_expand_args: Bool := Bool, **extra := Obj) -> Never
.Command._main_shell_completion: (self: core.Command, ctx_args: Obj, prog_name: Str, complete_var: NoneType or Str := NoneType or Str) -> NoneType
.Command.__call__: (self: NoneType or Str, *args: Obj, **kwargs := Obj) -> Never

.Type__FakeSubclassCheck: ClassType
.Type__FakeSubclassCheck <: Type
.Type__FakeSubclassCheck.__subclasscheck__: |Self <: global::Indexable(?K, ?V), K: Type, Type_18083 <: Structural({.__bases__ = ?Self}), V: Type|(cls: Type_18083, subclass: Type) -> Bool
.Type__FakeSubclassCheck.__instancecheck__: |K: Type, Self <: global::Indexable(?K, ?V), Type_18088 <: Structural({.__bases__ = ?Self}), V: Type|(cls: Type_18088, instance: Obj) -> Bool

.Type__BaseCommand: ClassType
core = pyimport "core"
.Type__BaseCommand <: .Command

.Group: ClassType
.Group <: .Command
.Group.commands: Never
.Group.invoke_without_command: Bool
.Group.subcommand_metavar: NoneType or Str
.Group.chain: Bool
.Group._result_callback: Never
.Group.no_args_is_help: NoneType or Bool
.Group.__call__: (name: NoneType or Str := NoneType or Str, commands: Obj := Obj, invoke_without_command: Bool := Bool, no_args_is_help: NoneType or Bool := NoneType or Bool, subcommand_metavar: NoneType or Str := NoneType or Str, chain: Bool := Bool, result_callback: Obj := Obj, **kwargs := Obj) -> core.Group
.Group.allow_extra_args: {True}
.Group.allow_interspersed_args: {False}
.Group.command_class: NoneType
.Group.group_class: NoneType
.Group.to_info_dict: Never
.Group.add_command: (self: core.Group, cmd: core.Command, name: NoneType or Str := NoneType or Str) -> NoneType
.Group.command: (self: core.Group, __func: Obj) -> core.Command
.Group.command: (self: core.Group, *args: Obj, **kwargs := Obj) -> {Ellipsis}
.Group.command: (self: core.Group, *args: Obj, **kwargs := Obj) -> (f: Obj) -> core.Command or core.Command
.Group.group: (self: core.Group, __func: Obj) -> core.Group
.Group.group: (self: core.Group, *args: Obj, **kwargs := Obj) -> {Ellipsis}
.Group.group: (self: core.Group, *args: Obj, **kwargs := Obj) -> (f: Obj) -> core.Group or core.Group
.Group.result_callback: (self: core.Group, replace: Bool := Bool) -> (f: Never) -> Never
.Group.get_command: (self: core.Group, ctx: core.Context, cmd_name: Str) -> NoneType or core.Command
.Group.list_commands: (self: core.Group, ctx: core.Context) -> global::List!(Str, _: Nat)
.Group.collect_usage_pieces: (self: core.Group, ctx: core.Context) -> global::List!(Str, _: Nat)
.Group.format_options: (self: core.Group, ctx: core.Context, formatter: Obj) -> NoneType
.Group.format_commands: (self: core.Group, ctx: core.Context, formatter: Obj) -> NoneType
.Group.parse_args: (self: core.Group, ctx: core.Context, args: global::List!(Str, _: Nat)) -> global::List!(Str, _: Nat)
.Group.invoke: (self: core.Group, ctx: core.Context) -> Never
.Group.resolve_command: (self: core.Group, ctx: core.Context, args: global::List!(Str, _: Nat)) -> global::Tuple([NoneType or Str, NoneType or core.Command, global::List!(Str, _: Nat)])
.Group.shell_complete: Never

.Type__MultiCommand: ClassType
.Type__MultiCommand <: .Group

.CommandCollection: ClassType
.CommandCollection <: .Group
.CommandCollection.sources: NoneType or global::List!(core.Group, _: Nat)
.CommandCollection.__call__: (name: NoneType or Str := NoneType or Str, sources: NoneType or global::List!(core.Group, _: Nat) := NoneType or global::List!(core.Group, _: Nat), **kwargs := Obj) -> core.CommandCollection
.CommandCollection.add_source: (self: core.CommandCollection, group: core.Group) -> NoneType
.CommandCollection.get_command: (self: core.CommandCollection, ctx: core.Context, cmd_name: Str) -> NoneType or core.Command
.CommandCollection.list_commands: (self: core.CommandCollection, ctx: core.Context) -> global::List!(Str, _: Nat)

._check_iter: |I <: global::Iterable(?T), T: Type|(value: Obj) -> ?I.Iterator
.Parameter: ClassType
.Parameter.type: Never
.Parameter.envvar: Never
.Parameter.is_eager: Bool
.Parameter.expose_value: Bool
.Parameter.metavar: NoneType or Str
.Parameter.nargs: NoneType or Int
.Parameter.default: Never
.Parameter.callback: Never
.Parameter.multiple: Bool
.Parameter.deprecated: Bool or Str
.Parameter.required: Bool
.Parameter._custom_shell_complete: Never
.Parameter.__call__: (param_decls: Obj := Obj, Type: Obj := Obj, required: Bool := Bool, default: Obj := Obj, callback: Obj := Obj, nargs: NoneType or Int := NoneType or Int, multiple: Bool := Bool, metavar: NoneType or Str := NoneType or Str, expose_value: Bool := Bool, is_eager: Bool := Bool, envvar: Obj := Obj, shell_complete: Obj := Obj, deprecated: Bool or Str := Bool or Str) -> core.Parameter
.Parameter.param_type_name: {"parameter"}
.Parameter.to_info_dict: Never
.Parameter.__repr__: (self: core.Parameter) -> Str
.Parameter._parse_decls: (self: core.Parameter, decls: Obj, expose_value: Bool) -> global::Tuple([NoneType or Str, global::List!(Str, _: Nat), global::List!(Str, _: Nat)])
.Parameter.human_readable_name : (self: core.Parameter) -> Str
.Parameter.human_readable_name: Str
.Parameter.make_metavar: (self: core.Parameter, ctx: core.Context) -> Str
.Parameter.get_default: (self: core.Parameter, ctx: core.Context, call: Obj := Obj) -> Never
.Parameter.get_default: (self: core.Parameter, ctx: core.Context, call: Bool := Bool) -> Never
.Parameter.get_default: (self: core.Parameter, ctx: core.Context, call: Bool := Bool) -> Never
.Parameter.add_to_parser: (self: core.Parameter, parser: Obj, ctx: core.Context) -> NoneType
.Parameter.consume_value: (self: core.Parameter, ctx: core.Context, opts: global::List(Never, _: Nat) or global::GenericDict) -> global::Tuple([Never, core.ParameterSource])
.Parameter.type_cast_value: (self: core.Parameter, ctx: core.Context, value: Obj) -> Never
.Parameter.value_is_missing: (self: core.Parameter, value: Obj) -> Bool
.Parameter.process_value: (self: core.Parameter, ctx: core.Context, value: Obj) -> Never
.Parameter.resolve_envvar_value: (self: core.Parameter, ctx: core.Context) -> NoneType or Str
.Parameter.value_from_envvar: (self: core.Parameter, ctx: core.Context) -> Never
.Parameter.handle_parse_result: (self: core.Parameter, ctx: core.Context, opts: global::Indexable(Obj, Never) or global::GenericDict or global::List(Never, _: Nat), args: global::List!(Str, _: Nat)) -> global::Tuple([Never, global::List!(Str, _: Nat)])
.Parameter.get_help_record: (self: core.Parameter, ctx: core.Context) -> global::Tuple([Str, Str]) or NoneType
.Parameter.get_usage_pieces: (self: core.Parameter, ctx: core.Context) -> global::List!(Str, _: Nat)
.Parameter.get_error_hint: (self: core.Parameter, ctx: core.Context) -> Str
.Parameter.shell_complete: Never

.Option: ClassType
.Option <: .Parameter
.Option.show_choices: Bool
.Option.help: NoneType or Str
.Option.hide_input: Bool
.Option.allow_from_autoenv: Bool
.Option.show_default: NoneType or Bool or Str
.Option.count: Bool
.Option.is_flag: NoneType or Bool
.Option.prompt: Bool or Str
.Option.is_bool_flag: Bool
.Option.show_envvar: Bool
.Option.flag_value: Never
.Option.hidden: Bool
.Option.confirmation_prompt: Bool or Str
.Option.prompt_required: Bool
.Option._flag_needs_value: Never
.Option.__call__: (param_decls: Obj := Obj, show_default: NoneType or Bool or Str := NoneType or Bool or Str, prompt: Bool or Str := Bool or Str, confirmation_prompt: Bool or Str := Bool or Str, prompt_required: Bool := Bool, hide_input: Bool := Bool, is_flag: NoneType or Bool := NoneType or Bool, flag_value: Obj := Obj, multiple: Bool := Bool, count: Bool := Bool, allow_from_autoenv: Bool := Bool, Type: Obj := Obj, help: NoneType or Str := NoneType or Str, hidden: Bool := Bool, show_choices: Bool := Bool, show_envvar: Bool := Bool, deprecated: Bool or Str := Bool or Str, **attrs := Obj) -> core.Option
.Option.param_type_name: {"option"}
.Option.to_info_dict: Never
.Option.get_error_hint: (self: core.Option, ctx: core.Context) -> Str
.Option._parse_decls: (self: core.Option, decls: global::Iterable(Never), expose_value: Bool) -> global::Tuple([NoneType or Str, global::List!(Str, _: Nat), global::List!(Str, _: Nat)])
.Option.add_to_parser: (self: core.Option, parser: Obj, ctx: core.Context) -> NoneType
.Option.get_help_record: (self: core.Option, ctx: core.Context) -> global::Tuple([Str, Str]) or NoneType
.Option.get_help_extra: (self: core.Option, ctx: core.Context) -> Never
.Option.get_default: (self: core.Option, ctx: core.Context, call: Obj := Obj) -> Never
.Option.get_default: (self: core.Option, ctx: core.Context, call: Bool := Bool) -> Never
.Option.get_default: (self: core.Option, ctx: core.Context, call: Bool := Bool) -> Never
.Option.prompt_for_value: (self: core.Option, ctx: core.Context) -> Never
.Option.resolve_envvar_value: (self: core.Option, ctx: core.Context) -> NoneType or Str
.Option.value_from_envvar: (self: core.Option, ctx: core.Context) -> Never
.Option.consume_value: (self: core.Option, ctx: core.Context, opts: Obj) -> global::Tuple([Never, core.ParameterSource])

.Argument: ClassType
.Argument <: .Parameter
.Argument.__call__: (param_decls: Obj, required: NoneType or Bool := NoneType or Bool, **attrs := Obj) -> core.Argument
.Argument.param_type_name: {"argument"}
.Argument.human_readable_name : (self: core.Argument) -> Str
.Argument.human_readable_name: Str
.Argument.make_metavar: (self: core.Argument, ctx: core.Context) -> Str
.Argument._parse_decls: (self: core.Argument, decls: Never, expose_value: Bool) -> global::Tuple([NoneType or Str, global::List!(Str, _: Nat), global::List!(Str, _: Nat)])
.Argument.get_usage_pieces: (self: core.Argument, ctx: core.Context) -> global::List!(Str, _: Nat)
.Argument.get_error_hint: (self: core.Argument, ctx: core.Context) -> Str
.Argument.add_to_parser: (self: core.Argument, parser: Obj, ctx: core.Context) -> NoneType

.__getattr__: (name: Str) -> Obj
